<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>1.在Python中实现离散傅里叶变换 | 一个数字自留地-DIY知识库</title><meta name="author" content="FAVE"><meta name="copyright" content="FAVE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="在处理录制视频时，发现有背景噪音，如何从音频中去除？ 需要识别噪声的频率，然后过滤出来。 如何确定频率？答案是傅里叶频率。 把信号分解为正弦波和余弦波，然后可以识别每个wave的幅度(amplitude)，频率(frequency)和相位(phase)，绘制每个频率的图像，我们可以隔离对信号贡献度最大的幅度。  在连续函数上的傅里叶变换： \hat{f}(k)&#x3D;\int_{-\infty}^\in">
<meta property="og:type" content="article">
<meta property="og:title" content="1.在Python中实现离散傅里叶变换">
<meta property="og:url" content="https://srrdhy.github.io/post/20250609110500.html">
<meta property="og:site_name" content="一个数字自留地-DIY知识库">
<meta property="og:description" content="在处理录制视频时，发现有背景噪音，如何从音频中去除？ 需要识别噪声的频率，然后过滤出来。 如何确定频率？答案是傅里叶频率。 把信号分解为正弦波和余弦波，然后可以识别每个wave的幅度(amplitude)，频率(frequency)和相位(phase)，绘制每个频率的图像，我们可以隔离对信号贡献度最大的幅度。  在连续函数上的傅里叶变换： \hat{f}(k)&#x3D;\int_{-\infty}^\in">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://srrdhy.github.io/img/article02.jpg">
<meta property="article:published_time" content="2025-06-09T03:05:00.000Z">
<meta property="article:modified_time" content="2025-06-09T08:31:06.007Z">
<meta property="article:author" content="FAVE">
<meta property="article:tag" content="Python-Fourier">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://srrdhy.github.io/img/article02.jpg"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "1.在Python中实现离散傅里叶变换",
  "url": "https://srrdhy.github.io/post/20250609110500.html",
  "image": "https://srrdhy.github.io/img/article02.jpg",
  "datePublished": "2025-06-09T03:05:00.000Z",
  "dateModified": "2025-06-09T08:31:06.007Z",
  "author": [
    {
      "@type": "Person",
      "name": "FAVE",
      "url": "https://srrdhy.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://srrdhy.github.io/post/20250609110500.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '1.在Python中实现离散傅里叶变换',
  isHighlightShrink: false,
  isToc: false,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/article02.jpg);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">一个数字自留地-DIY知识库</span></a><a class="nav-page-title" href="/"><span class="site-name">1.在Python中实现离散傅里叶变换</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">1.在Python中实现离散傅里叶变换</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-09T03:05:00.000Z" title="发表于 2025-06-09 11:05:00">2025-06-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-06-09T08:31:06.007Z" title="更新于 2025-06-09 16:31:06">2025-06-09</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><p>在处理录制视频时，发现有背景噪音，如何从音频中去除？</p>
<p>需要识别噪声的频率，然后过滤出来。</p>
<p>如何确定频率？答案是傅里叶频率。</p>
<p>把信号分解为正弦波和余弦波，然后可以识别每个wave的幅度(amplitude)，频率(frequency)和相位(phase)，绘制每个频率的图像，我们可以隔离对信号贡献度最大的幅度。</p>
<p><img src="/img/article02/0_Ar9pfLsqExa5pY85.gif" alt=""></p>
<p>在连续函数上的傅里叶变换：</p>
<script type="math/tex; mode=display">\hat{f}(k)=\int_{-\infty}^\infty f(t)e^{-i2\pi kt}dt</script><p>但在现实中，信号是离散的，因此我们有离散的傅里叶变换(DFT)：</p>
<script type="math/tex; mode=display">X[k]=\sum_{n=0}^{N-1}x[n]e^{-i2\pi\frac{k}{N}n}</script><p>在这里：</p>
<ul>
<li>$N$是采样数量</li>
<li>$n$是当前样本的序号</li>
<li>$k$是当前频率</li>
<li>$x[n]$是$n$处信号值</li>
<li>$X[k]$是当前$k$对应的DFT</li>
</ul>
<p>接下来让我们在Python中见证DFT的魔力。</p>
<p>首先导入一些库<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br></pre></td></tr></table></figure></p>
<p>接下来，定义采样速率以定义时间的数组<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rate = <span class="number">100</span> <span class="comment"># rate 是采样率（每秒采样点数，单位：Hz）</span></span><br><span class="line">interval = <span class="number">1</span> / rate</span><br><span class="line"></span><br><span class="line">t_start = <span class="number">0</span></span><br><span class="line">t_end = <span class="number">1</span></span><br><span class="line">t = np.arange(t_start, t_end, interval) <span class="comment"># (0, 1, 1/100)  时间采样</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(t)) <span class="comment"># 100</span></span><br></pre></td></tr></table></figure></p>
<p>现在，我们要生成一个由3个正弦波组合的信号。让我们编写一个接受振幅和频率数组并生成组合信号的函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">getSineSignal</span>(<span class="params">amps, freqs, t</span>):  <span class="comment"># 接受振幅和频率数组并生成组合信号的函数</span></span><br><span class="line">    x = np.zeros_like(t)</span><br><span class="line">    <span class="keyword">for</span> a, f <span class="keyword">in</span> <span class="built_in">zip</span>(amps, freqs): </span><br><span class="line">        x += a * np.sin(<span class="number">2</span> * np.pi * f * t)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p>
<p>添加3个正弦波，幅度依次是9，10，2.3，频率依次是2，1，10<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">amps = np.array([<span class="number">9</span>, <span class="number">10</span>, <span class="number">2.3</span>])</span><br><span class="line">freqs = np.array([<span class="number">2</span>, <span class="number">1</span>, <span class="number">10</span>])</span><br><span class="line">x = getSineSignal(amps, freqs, t)</span><br></pre></td></tr></table></figure></p>
<p>这三个正弦波的图像如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">signal1 = amps[<span class="number">0</span>] * np.sin(<span class="number">2</span> * np.pi * freqs[<span class="number">0</span>] * t)</span><br><span class="line">signal2 = amps[<span class="number">1</span>] * np.sin(<span class="number">2</span> * np.pi * freqs[<span class="number">1</span>] * t)</span><br><span class="line">signal3 = amps[<span class="number">2</span>] * np.sin(<span class="number">2</span> * np.pi * freqs[<span class="number">2</span>] * t)</span><br><span class="line"></span><br><span class="line">fig, axs = plt.subplots(<span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">12</span>, <span class="number">3</span>))  <span class="comment"># 1行3列</span></span><br><span class="line"></span><br><span class="line">axs[<span class="number">0</span>].plot(t, signal1, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">axs[<span class="number">0</span>].set_ylabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">axs[<span class="number">0</span>].grid()</span><br><span class="line"></span><br><span class="line">axs[<span class="number">1</span>].plot(t, signal2, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">axs[<span class="number">1</span>].set_ylabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">axs[<span class="number">1</span>].grid()</span><br><span class="line"></span><br><span class="line">axs[<span class="number">2</span>].plot(t, signal3, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">axs[<span class="number">2</span>].set_xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">axs[<span class="number">2</span>].set_ylabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">axs[<span class="number">2</span>].grid()</span><br><span class="line"></span><br><span class="line">plt.tight_layout()  <span class="comment"># 自动调整子图间距</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/article02/001.png" alt=""></p>
<p>组合后的信号：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">plt.plot(t, x, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/article02/002.png" alt=""></p>
<p>现在，让我们编写一个在数组上执行DFT操作的函数。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">DFT</span>(<span class="params">x</span>):</span><br><span class="line">    N = x.size</span><br><span class="line">    n = np.arange(N)</span><br><span class="line">    k = n.reshape((N, <span class="number">1</span>)) <span class="comment"># 频率索引  0到N-1，N个采样点，最多可能由N个频率下的曲线合成， 包含pi的频率已经隐含在公式中了</span></span><br><span class="line"></span><br><span class="line">    e = np.exp(-<span class="number">2j</span> * np.pi * k * n / N)  <span class="comment">#  这个矩阵是 DFT 的基函数矩阵，包含了所有频率分量的复指数。 矩阵的每一行对应一个频率</span></span><br><span class="line">    X_k = np.zeros_like(k, dtype=np.complex128)  <span class="comment"># 包含了复数，要声明这是个复杂的数组</span></span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> n: <span class="comment"># 对应频域索引 k </span></span><br><span class="line">        <span class="keyword">for</span> col <span class="keyword">in</span> n:  <span class="comment"># 对应时间域索引 n</span></span><br><span class="line">            X_k[row] += e[row, col] * x[col]</span><br><span class="line">    <span class="keyword">return</span> X_k  <span class="comment"># 一个 N×1 的复数数组，表示输入信号在频域的表示</span></span><br></pre></td></tr></table></figure></p>
<p>补充一下numpy中的exp算法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>]])</span><br><span class="line">test = np.exp(a)  <span class="comment"># 对矩阵内所有元素e^</span></span><br><span class="line"><span class="built_in">print</span>(test)</span><br><span class="line"></span><br><span class="line"><span class="comment"># [[2.71828183 2.71828183 7.3890561 ] [2.71828183 7.3890561 2.71828183]]</span></span><br></pre></td></tr></table></figure></p>
<p>让我们来验证一下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(x.shape)</span><br><span class="line"><span class="built_in">print</span>(x[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(100,)</span></span><br><span class="line"><span class="string">[0.         3.10781038 5.67897131 7.37436411 8.17458802]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">X_k = DFT(x)</span><br><span class="line"><span class="built_in">print</span>(X_k.shape)</span><br><span class="line"><span class="built_in">print</span>(X_k[:<span class="number">5</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">(100, 1)</span></span><br><span class="line"><span class="string">[[-4.35207426e-14+0.00000000e+00j]</span></span><br><span class="line"><span class="string"> [ 7.10542736e-14-5.00000000e+02j]</span></span><br><span class="line"><span class="string"> [-4.44089210e-16-4.50000000e+02j]</span></span><br><span class="line"><span class="string"> [-1.62536651e-13-7.62723218e-14j]</span></span><br><span class="line"><span class="string"> [-4.39648318e-14+1.25455202e-14j]]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure>
<p>让我们绘制振幅随频率变化的图<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">X_k = DFT(x)</span><br><span class="line">N = X_k.size <span class="comment"># 信号的采样点数</span></span><br><span class="line">n = np.arange(N) <span class="comment"># 表示频域的索引（对应频率分量的编号）</span></span><br><span class="line">T = N / rate  <span class="comment"># 计算信号的总时长 T（单位：秒）</span></span><br><span class="line">freq = n / T <span class="comment"># 计算频率轴的刻度 freq   n / T 将索引 n 转换为实际频率（Hz）</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">plt.stem(freq, <span class="built_in">abs</span>(X_k), <span class="string">&#x27;b&#x27;</span>, markerfmt=<span class="string">&#x27; &#x27;</span>, basefmt=<span class="string">&#x27;-b&#x27;</span>) </span><br><span class="line"><span class="comment"># &#x27;b&#x27; 表示使用蓝色线条</span></span><br><span class="line"><span class="comment"># markerfmt=&#x27; &#x27; 表示茎的顶部不显示标记点</span></span><br><span class="line"><span class="comment"># basefmt=&#x27;-b&#x27; 表示基线为蓝色实线</span></span><br><span class="line"></span><br><span class="line">plt.xlabel(<span class="string">r&#x27;$\omega$ &#x27;</span>+<span class="string">&#x27;(Hz)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;DFT Amplitude &#x27;</span>+<span class="string">r&#x27;$|X(\omega)|$&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/article02/003.png" alt=""></p>
<p>该图称为振幅频谱图，在采样率的一半上是对称的。这是一个被称为Nyquist-Shannon定理的结果。</p>
<p>注意abs绝对值可以计算复数的模，也就是幅度：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z1 = <span class="number">3</span> + <span class="number">4j</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(z1))  <span class="comment"># 5.0</span></span><br></pre></td></tr></table></figure></p>
<p>我们可以看到3个主要信号的频率！直接把振幅打印出来：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(X_k)[<span class="number">1</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(X_k)[<span class="number">2</span>])</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">abs</span>(X_k)[<span class="number">10</span>])</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">[500.]</span></span><br><span class="line"><span class="string">[450.]</span></span><br><span class="line"><span class="string">[115.]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure></p>
<p>让我们卸下右半，然后放大频谱。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">n_oneside = N // <span class="number">2</span></span><br><span class="line"><span class="comment"># 对于实数输入信号，DFT 的频谱是对称的（负频率和正频率幅度相同），因此通常只分析 0 到 Nyquist 频率（采样率的一半）之间的部分</span></span><br><span class="line">f_oneside = freq[:n_oneside] <span class="comment"># 提取单边频率轴</span></span><br><span class="line">X_k_oneside = X_k[:n_oneside] / n_oneside <span class="comment"># 计算单边幅度谱并进行归一化 频率 1，2，10对应的幅度是10，9，2.3</span></span><br><span class="line"><span class="comment"># 归一化是为了让单边幅度谱的幅度值反映信号的真实强度，通常在实信号的单边谱中需要将幅度除以 N/2</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize = (<span class="number">12</span>, <span class="number">6</span>))</span><br><span class="line">plt.subplot(<span class="number">121</span>)</span><br><span class="line">plt.stem(f_oneside, <span class="built_in">abs</span>(X_k_oneside), <span class="string">&#x27;b&#x27;</span>, markerfmt=<span class="string">&quot; &quot;</span>, basefmt=<span class="string">&quot;-b&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Freq (Hz)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;DFT Amplitude |X(freq)|&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.subplot(<span class="number">122</span>)</span><br><span class="line">plt.stem(f_oneside, <span class="built_in">abs</span>(X_k_oneside), <span class="string">&#x27;b&#x27;</span>, markerfmt=<span class="string">&quot; &quot;</span>, basefmt=<span class="string">&quot;-b&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Freq (Hz)&#x27;</span>)</span><br><span class="line">plt.xlim(<span class="number">0</span>, <span class="number">12</span>) <span class="comment"># 限制 x 轴范围为 0 到 12 Hz，放大低频区域以观察细节</span></span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></p>
<p><img src="/img/article02/004.png" alt=""></p>
<p>可以看到，频率和振幅与我们最初的正弦波相匹配。</p>
<p>使用numpy矩阵点乘改进我们的DFT算法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">vDFT</span>(<span class="params">x</span>):</span><br><span class="line">    N = x.size</span><br><span class="line">    n = np.arange(N)</span><br><span class="line">    k = n.reshape((N, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    e = np.exp(-<span class="number">2j</span> * np.pi * k * n / N)</span><br><span class="line">    X_k = np.dot(e, x)</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> X_k</span><br></pre></td></tr></table></figure></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X_k = vDFT(x)</span><br><span class="line">N = X_k.size</span><br><span class="line">n = np.arange(N)</span><br><span class="line">T = N / rate</span><br><span class="line">freq = n / T</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">8</span>,<span class="number">6</span>))</span><br><span class="line">plt.stem(freq, <span class="built_in">abs</span>(X_k), <span class="string">&#x27;b&#x27;</span>, markerfmt=<span class="string">&#x27; &#x27;</span>, basefmt=<span class="string">&#x27;-b&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">r&#x27;$\omega$ &#x27;</span>+<span class="string">&#x27;(Hz)&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;DFT Amplitude &#x27;</span>+<span class="string">r&#x27;$|X(\omega)|$&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br></pre></td></tr></table></figure>
<p><img src="/img/article02/005.png" alt=""></p>
<p>效果是一样的，速度上快了大约10倍。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://srrdhy.github.io">FAVE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://srrdhy.github.io/post/20250609110500.html">https://srrdhy.github.io/post/20250609110500.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://srrdhy.github.io" target="_blank">一个数字自留地-DIY知识库</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python-Fourier/">Python-Fourier</a></div><div class="post-share"><div class="social-share" data-image="/img/article02.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/post/20250608211627.html" title="Hello World"><img class="cover" src="/img/article01.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Hello World</div></div><div class="info-2"><div class="info-item-1">Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment </div></div></div></a><a class="pagination-related" href="/post/20250609164912.html" title="2.实现Python中的离散傅里叶逆变换"><img class="cover" src="/img/article03.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">2.实现Python中的离散傅里叶逆变换</div></div><div class="info-2"><div class="info-item-1">在上一篇文章中，我们在Python中实施了离散的傅里叶变换（DFT）。 在本文中，让我们看一下逆过程：将频率值向量转换为时间值的向量。 从数学上讲，反离散的傅里叶变换（IDFT）由以下方式给出： $$x[n]&#x3D;\frac{1}{N}\sum_{k&#x3D;0}^{N-1}X[k]\cdot e^{i2\pi\frac{k}{N}n}$$其中：  $N$是采样数量 $n$是当前样本的序号 $k$是当前频率 $X[k]$是$n$处的DFT $x[n]$是$n$处的iDFT  由于离散傅里叶变换的矩阵是方形且可逆的，因此反向变换是可行的。理想情况下，我们应该能够收回我们的原始嘈杂信号。 前期准备： 123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npimport matplotlib.pyplot as pltrate = 100 # rate 是采样率（每秒采样点数，单位：Hz）interval = 1 / ratet_start =...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/post/20250609164912.html" title="2.实现Python中的离散傅里叶逆变换"><img class="cover" src="/img/article03.jpg" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-09</div><div class="info-item-2">2.实现Python中的离散傅里叶逆变换</div></div><div class="info-2"><div class="info-item-1">在上一篇文章中，我们在Python中实施了离散的傅里叶变换（DFT）。 在本文中，让我们看一下逆过程：将频率值向量转换为时间值的向量。 从数学上讲，反离散的傅里叶变换（IDFT）由以下方式给出： $$x[n]&#x3D;\frac{1}{N}\sum_{k&#x3D;0}^{N-1}X[k]\cdot e^{i2\pi\frac{k}{N}n}$$其中：  $N$是采样数量 $n$是当前样本的序号 $k$是当前频率 $X[k]$是$n$处的DFT $x[n]$是$n$处的iDFT  由于离散傅里叶变换的矩阵是方形且可逆的，因此反向变换是可行的。理想情况下，我们应该能够收回我们的原始嘈杂信号。 前期准备： 123456789101112131415161718192021222324252627282930313233343536373839404142import numpy as npimport matplotlib.pyplot as pltrate = 100 # rate 是采样率（每秒采样点数，单位：Hz）interval = 1 / ratet_start =...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">FAVE</div><div class="author-info-description">技术博客, 记录物理学, 数学与AI的探索</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">5</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">1</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/srrdhy"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/srrdhy" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/post/20250609164912.html" title="2.实现Python中的离散傅里叶逆变换"><img src="/img/article03.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="2.实现Python中的离散傅里叶逆变换"/></a><div class="content"><a class="title" href="/post/20250609164912.html" title="2.实现Python中的离散傅里叶逆变换">2.实现Python中的离散傅里叶逆变换</a><time datetime="2025-06-09T08:49:12.000Z" title="发表于 2025-06-09 16:49:12">2025-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/20250609164912.html" title="3.在Python中实现快速傅里叶变换(FFT)"><img src="/img/article04.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="3.在Python中实现快速傅里叶变换(FFT)"/></a><div class="content"><a class="title" href="/post/20250609164912.html" title="3.在Python中实现快速傅里叶变换(FFT)">3.在Python中实现快速傅里叶变换(FFT)</a><time datetime="2025-06-09T08:49:12.000Z" title="发表于 2025-06-09 16:49:12">2025-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/20250609164912.html" title="4.使用Scipy库中的fft"><img src="/img/article05.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="4.使用Scipy库中的fft"/></a><div class="content"><a class="title" href="/post/20250609164912.html" title="4.使用Scipy库中的fft">4.使用Scipy库中的fft</a><time datetime="2025-06-09T08:49:12.000Z" title="发表于 2025-06-09 16:49:12">2025-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/20250609110500.html" title="1.在Python中实现离散傅里叶变换"><img src="/img/article02.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="1.在Python中实现离散傅里叶变换"/></a><div class="content"><a class="title" href="/post/20250609110500.html" title="1.在Python中实现离散傅里叶变换">1.在Python中实现离散傅里叶变换</a><time datetime="2025-06-09T03:05:00.000Z" title="发表于 2025-06-09 11:05:00">2025-06-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/post/20250608211627.html" title="Hello World"><img src="/img/article01.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/post/20250608211627.html" title="Hello World">Hello World</a><time datetime="2025-06-08T13:16:27.928Z" title="发表于 2025-06-08 21:16:27">2025-06-08</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By FAVE</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"><script>(() => {
  const loadMathjax = () => {
    if (!window.MathJax) {
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          tags: 'none',
        },
        chtml: {
          scale: 1.1
        },
        options: {
          enableMenu: true,
          renderActions: {
            findScript: [10, doc => {
              for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
                const display = !!node.type.match(/; *mode=display/)
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
                const text = document.createTextNode('')
                node.parentNode.replaceChild(text, node)
                math.start = {node: text, delim: '', n: 0}
                math.end = {node: text, delim: '', n: 0}
                doc.math.push(math)
              }
            }, '']
          }
        }
      }

      const script = document.createElement('script')
      script.src = 'https://cdn.jsdelivr.net/npm/mathjax/es5/tex-mml-chtml.min.js'
      script.id = 'MathJax-script'
      script.async = true
      document.head.appendChild(script)
    } else {
      MathJax.startup.document.state(0)
      MathJax.texReset()
      MathJax.typesetPromise()
    }
  }

  btf.addGlobalFn('encrypt', loadMathjax, 'mathjax')
  window.pjax ? loadMathjax() : window.addEventListener('load', loadMathjax)
})()</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>